// This file was generated by gir (https://github.com/gtk-rs/gir)
// from /nix/store/4dxx74s4g3rrn6haryx8i6yzy91f5q7m-source
// from /nix/store/687zj3l24wawn3a93nkqqcv6g0hjm9n5-dbusmenu-gtk3-gir
// DO NOT EDIT

use crate::{Menuitem, Status, TextDirection};
use glib::{
    prelude::*,
    signal::{connect_raw, SignalHandlerId},
    translate::*,
};
use std::{boxed::Box as Box_, fmt, mem::transmute};

glib::wrapper! {
    #[doc(alias = "DbusmenuServer")]
    pub struct Server(Object<ffi::DbusmenuServer, ffi::DbusmenuServerClass>);

    match fn {
        type_ => || ffi::dbusmenu_server_get_type(),
    }
}

impl Server {
    pub const NONE: Option<&'static Server> = None;

    /// Creates a new [`Server`][crate::Server] object with a specific object
    ///     path on DBus. If `object` is set to NULL the default object
    ///     name of "/com/canonical/dbusmenu" will be used.
    ///
    /// Return value: A brand new [`Server`][crate::Server]
    /// ## `object`
    /// The object name to show for this menu structure
    ///         on DBus. May be NULL.
    #[doc(alias = "dbusmenu_server_new")]
    pub fn new(object: &str) -> Server {
        assert_initialized_main_thread!();
        unsafe { from_glib_full(ffi::dbusmenu_server_new(object.to_glib_none().0)) }
    }
}

/// Trait containing all [`struct@Server`] methods.
///
/// # Implementors
///
/// [`Server`][struct@crate::Server]
pub trait ServerExt: 'static {
    /// Gets the stored and exported icon paths from the server.
    ///
    /// # Returns
    ///
    /// A NULL-terminated list of icon paths with
    ///  memory managed by the server. Duplicate if you want
    ///  to keep them.
    #[doc(alias = "dbusmenu_server_get_icon_paths")]
    #[doc(alias = "get_icon_paths")]
    fn icon_paths(&self) -> Vec<glib::GString>;

    /// Gets the current statust hat the server is sending out over
    ///     DBus.
    ///
    /// Return value: The current status the server is sending
    #[doc(alias = "dbusmenu_server_get_status")]
    #[doc(alias = "get_status")]
    fn status(&self) -> Status;

    /// Returns the value of the text direction that is being exported
    ///     over DBus for this server. It should relate to the direction
    ///     of the labels and other text fields that are being exported by
    ///     this server.
    ///
    /// Return value: Text direction exported for this server.
    #[doc(alias = "dbusmenu_server_get_text_direction")]
    #[doc(alias = "get_text_direction")]
    fn text_direction(&self) -> TextDirection;

    /// Sets the icon paths for the server. This will replace previously
    ///     set icon theme paths.
    #[doc(alias = "dbusmenu_server_set_icon_paths")]
    fn set_icon_paths(&self, icon_paths: &[&str]);

    /// This function contains all of the `GValue` wrapping
    ///     required to set the property [`root-node`][struct@crate::Server#root-node]
    ///     on the server `self`.
    /// ## `root`
    /// The new root [`Menuitem`][crate::Menuitem] tree
    #[doc(alias = "dbusmenu_server_set_root")]
    fn set_root(&self, root: &impl IsA<Menuitem>);

    /// Changes the status of the server.
    /// ## `status`
    /// Status value to set on the server
    #[doc(alias = "dbusmenu_server_set_status")]
    fn set_status(&self, status: Status);

    /// Sets the text direction that should be exported over DBus for
    ///     this server. If the value is set to [`TextDirection::None`][crate::TextDirection::None]
    ///     the default detection will be used for setting the value and
    ///     exported over DBus.
    /// ## `dir`
    /// Direction of the text
    #[doc(alias = "dbusmenu_server_set_text_direction")]
    fn set_text_direction(&self, dir: TextDirection);

    #[doc(alias = "dbus-object")]
    fn dbus_object(&self) -> Option<glib::GString>;

    #[doc(alias = "root-node")]
    fn root_node(&self) -> Option<Menuitem>;

    #[doc(alias = "root-node")]
    fn set_root_node<P: IsA<Menuitem>>(&self, root_node: Option<&P>);

    fn version(&self) -> u32;

    /// This is signaled when a menuitem under this server
    ///         sends its activate signal.
    /// ## `arg1`
    /// The ID of the parent for this update.
    /// ## `arg2`
    /// The timestamp of when the event happened
    #[doc(alias = "item-activation-requested")]
    fn connect_item_activation_requested<F: Fn(&Self, i32, u32) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[doc(alias = "item-property-updated")]
    fn connect_item_property_updated<F: Fn(&Self, i32, &str, &glib::Variant) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[doc(alias = "item-updated")]
    fn connect_item_updated<F: Fn(&Self, i32) + 'static>(&self, f: F) -> SignalHandlerId;

    /// This signal is emitted any time the layout of the
    ///         menuitems under this server is changed.
    /// ## `arg1`
    /// A revision number representing which revision the update
    ///          represents itself as.
    /// ## `arg2`
    /// The ID of the parent for this update.
    #[doc(alias = "layout-updated")]
    fn connect_layout_updated<F: Fn(&Self, u32, i32) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "root-node")]
    fn connect_root_node_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "version")]
    fn connect_version_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<Server>> ServerExt for O {
    fn icon_paths(&self) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::dbusmenu_server_get_icon_paths(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn status(&self) -> Status {
        unsafe {
            from_glib(ffi::dbusmenu_server_get_status(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn text_direction(&self) -> TextDirection {
        unsafe {
            from_glib(ffi::dbusmenu_server_get_text_direction(
                self.as_ref().to_glib_none().0,
            ))
        }
    }



    fn set_icon_paths(&self, icon_paths: &[&str]) {
        unsafe {
            ffi::dbusmenu_server_set_icon_paths(
                self.as_ref().to_glib_none().0,
                icon_paths.to_glib_none().0,
            );
        }
    }

    fn set_root(&self, root: &impl IsA<Menuitem>) {
        unsafe {
            ffi::dbusmenu_server_set_root(
                self.as_ref().to_glib_none().0,
                root.as_ref().to_glib_none().0,
            );
        }
    }

    fn set_status(&self, status: Status) {
        unsafe {
            ffi::dbusmenu_server_set_status(self.as_ref().to_glib_none().0, status.into_glib());
        }
    }

    fn set_text_direction(&self, dir: TextDirection) {
        unsafe {
            ffi::dbusmenu_server_set_text_direction(
                self.as_ref().to_glib_none().0,
                dir.into_glib(),
            );
        }
    }

    fn dbus_object(&self) -> Option<glib::GString> {
        glib::prelude::ObjectExt::property(self.as_ref(), "dbus-object")
    }

    fn root_node(&self) -> Option<Menuitem> {
        glib::prelude::ObjectExt::property(self.as_ref(), "root-node")
    }

    fn set_root_node<P: IsA<Menuitem>>(&self, root_node: Option<&P>) {
        glib::prelude::ObjectExt::set_property(self.as_ref(), "root-node", root_node)
    }

    fn version(&self) -> u32 {
        glib::prelude::ObjectExt::property(self.as_ref(), "version")
    }

    fn connect_item_activation_requested<F: Fn(&Self, i32, u32) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn item_activation_requested_trampoline<
            P: IsA<Server>,
            F: Fn(&P, i32, u32) + 'static,
        >(
            this: *mut ffi::DbusmenuServer,
            arg1: libc::c_int,
            arg2: libc::c_uint,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Server::from_glib_borrow(this).unsafe_cast_ref(), arg1, arg2)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"item-activation-requested\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    item_activation_requested_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_item_property_updated<F: Fn(&Self, i32, &str, &glib::Variant) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn item_property_updated_trampoline<
            P: IsA<Server>,
            F: Fn(&P, i32, &str, &glib::Variant) + 'static,
        >(
            this: *mut ffi::DbusmenuServer,
            object: libc::c_int,
            p0: *mut libc::c_char,
            p1: *mut glib::ffi::GVariant,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(
                Server::from_glib_borrow(this).unsafe_cast_ref(),
                object,
                &glib::GString::from_glib_borrow(p0),
                &from_glib_borrow(p1),
            )
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"item-property-updated\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    item_property_updated_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_item_updated<F: Fn(&Self, i32) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn item_updated_trampoline<P: IsA<Server>, F: Fn(&P, i32) + 'static>(
            this: *mut ffi::DbusmenuServer,
            object: libc::c_int,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Server::from_glib_borrow(this).unsafe_cast_ref(), object)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"item-updated\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    item_updated_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_layout_updated<F: Fn(&Self, u32, i32) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn layout_updated_trampoline<
            P: IsA<Server>,
            F: Fn(&P, u32, i32) + 'static,
        >(
            this: *mut ffi::DbusmenuServer,
            arg1: libc::c_uint,
            arg2: libc::c_int,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Server::from_glib_borrow(this).unsafe_cast_ref(), arg1, arg2)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"layout-updated\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    layout_updated_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_root_node_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_root_node_trampoline<P: IsA<Server>, F: Fn(&P) + 'static>(
            this: *mut ffi::DbusmenuServer,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Server::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::root-node\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_root_node_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_version_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_version_trampoline<P: IsA<Server>, F: Fn(&P) + 'static>(
            this: *mut ffi::DbusmenuServer,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Server::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::version\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_version_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl fmt::Display for Server {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("Server")
    }
}
