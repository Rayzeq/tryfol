// This file was generated by gir (https://github.com/gtk-rs/gir)
// from /nix/store/4dxx74s4g3rrn6haryx8i6yzy91f5q7m-source
// from /nix/store/687zj3l24wawn3a93nkqqcv6g0hjm9n5-dbusmenu-gtk3-gir
// DO NOT EDIT

use crate::{Menuitem, Status, TextDirection};
use glib::{
    prelude::*,
    signal::{connect_raw, SignalHandlerId},
    translate::*,
};
use std::{boxed::Box as Box_, fmt, mem::transmute};

glib::wrapper! {
    #[doc(alias = "DbusmenuClient")]
    pub struct Client(Object<ffi::DbusmenuClient, ffi::DbusmenuClientClass>);

    match fn {
        type_ => || ffi::dbusmenu_client_get_type(),
    }
}

impl Client {
    pub const NONE: Option<&'static Client> = None;

    /// This function creates a new client that connects to a specific
    /// server on DBus. That server is at a specific location sharing
    /// a known object. The interface is assumed by the code to be
    /// the DBus menu interface. The newly created client will start
    /// sending out events as it syncs up with the server.
    /// ## `name`
    /// The DBus name for the server to connect to
    /// ## `object`
    /// The object on the server to monitor
    ///
    /// # Returns
    ///
    /// A brand new [`Client`][crate::Client]
    #[doc(alias = "dbusmenu_client_new")]
    pub fn new(name: &str, object: &str) -> Client {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::dbusmenu_client_new(
                name.to_glib_none().0,
                object.to_glib_none().0,
            ))
        }
    }
}

/// Trait containing all [`struct@Client`] methods.
///
/// # Implementors
///
/// [`Client`][struct@crate::Client]
pub trait ClientExt: 'static {
    /// This function connects into the type handling of the [`Client`][crate::Client].
    /// Every new menuitem that comes in immediately gets asked for its
    /// properties. When we get those properties we check the 'type'
    /// property and look to see if it matches a handler that is known
    /// by the client. If so, the `newfunc` function is executed on that
    /// [`Menuitem`][crate::Menuitem]. If not, then the DbusmenuClient::new-menuitem
    /// signal is sent.
    ///
    /// In the future the known types will be sent to the server so that it
    /// can make choices about the menu item types availble.
    /// ## `type_`
    /// A text string that will be matched with the 'type'
    ///  property on incoming menu items
    /// ## `newfunc`
    /// The function that will be executed with those new
    ///  items when they come in.
    ///
    /// # Returns
    ///
    /// If registering the new type was successful.
    #[doc(alias = "dbusmenu_client_add_type_handler_full")]
    fn add_type_handler_full<P: Fn(&Menuitem, &Menuitem, &Client) -> bool + 'static>(
        &self,
        type_: &str,
        newfunc: P,
    ) -> bool;

    /// Gets the stored and exported icon paths from the client.
    ///
    /// # Returns
    ///
    /// A NULL-terminated list of icon paths with
    ///  memory managed by the client. Duplicate if you want
    ///  to keep them.
    #[doc(alias = "dbusmenu_client_get_icon_paths")]
    #[doc(alias = "get_icon_paths")]
    fn icon_paths(&self) -> Vec<glib::GString>;

    /// Grabs the root node for the specified client `self`. This
    /// function may block. It will block if there is currently a
    /// call to update the layout, it will block on that layout
    /// updated and then return the newly updated layout. Chances
    /// are that this update is in the queue for the mainloop as
    /// it would have been requested some time ago, but in theory
    /// it could block longer.
    ///
    /// # Returns
    ///
    /// A [`Menuitem`][crate::Menuitem] representing the root of
    ///     menu on the server. If there is no server or there is
    ///     an error receiving its layout it'll return [`None`].
    #[doc(alias = "dbusmenu_client_get_root")]
    #[doc(alias = "get_root")]
    fn root(&self) -> Option<Menuitem>;

    /// Gets the recommended current status that the server
    ///     is exporting for the menus. In situtations where the
    ///     value is [`Status::Notice`][crate::Status::Notice] it is recommended that
    ///     the client show the menus to the user an a more noticible
    ///     way.
    ///
    /// Return value: Status being exported.
    #[doc(alias = "dbusmenu_client_get_status")]
    #[doc(alias = "get_status")]
    fn status(&self) -> Status;

    /// Gets the text direction that the server is exporting. If
    ///     the server is not exporting a direction then the value
    ///     [`TextDirection::None`][crate::TextDirection::None] will be returned.
    ///
    /// Return value: Text direction being exported.
    #[doc(alias = "dbusmenu_client_get_text_direction")]
    #[doc(alias = "get_text_direction")]
    fn text_direction(&self) -> TextDirection;

    #[doc(alias = "dbus-name")]
    fn dbus_name(&self) -> Option<glib::GString>;

    #[doc(alias = "dbus-object")]
    fn dbus_object(&self) -> Option<glib::GString>;

    #[doc(alias = "group-events")]
    fn is_group_events(&self) -> bool;

    #[doc(alias = "group-events")]
    fn set_group_events(&self, group_events: bool);

    //#[doc(alias = "event-result")]
    //fn connect_event_result<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    //#[doc(alias = "icon-theme-dirs-changed")]
    //fn connect_icon_theme_dirs_changed<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    //#[doc(alias = "item-activate")]
    //fn connect_item_activate<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "layout-updated")]
    fn connect_layout_updated<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    //#[doc(alias = "new-menuitem")]
    //fn connect_new_menuitem<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    //#[doc(alias = "root-changed")]
    //fn connect_root_changed<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "group-events")]
    fn connect_group_events_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<Client>> ClientExt for O {
    fn add_type_handler_full<P: Fn(&Menuitem, &Menuitem, &Client) -> bool + 'static>(
        &self,
        type_: &str,
        newfunc: P,
    ) -> bool {
        let newfunc_data: Box_<P> = Box_::new(newfunc);
        unsafe extern "C" fn newfunc_func<
            P: Fn(&Menuitem, &Menuitem, &Client) -> bool + 'static,
        >(
            newitem: *mut ffi::DbusmenuMenuitem,
            parent: *mut ffi::DbusmenuMenuitem,
            client: *mut ffi::DbusmenuClient,
            user_data: glib::ffi::gpointer,
        ) -> glib::ffi::gboolean {
            let newitem = from_glib_borrow(newitem);
            let parent = from_glib_borrow(parent);
            let client = from_glib_borrow(client);
            let callback: &P = &*(user_data as *mut _);
            (*callback)(&newitem, &parent, &client).into_glib()
        }
        let newfunc = Some(newfunc_func::<P> as _);
        unsafe extern "C" fn destroy_func_func<
            P: Fn(&Menuitem, &Menuitem, &Client) -> bool + 'static,
        >(
            data: glib::ffi::gpointer,
        ) {
            let _callback: Box_<P> = Box_::from_raw(data as *mut _);
        }
        let destroy_call4 = Some(destroy_func_func::<P> as _);
        let super_callback0: Box_<P> = newfunc_data;
        unsafe {
            from_glib(ffi::dbusmenu_client_add_type_handler_full(
                self.as_ref().to_glib_none().0,
                type_.to_glib_none().0,
                newfunc,
                Box_::into_raw(super_callback0) as *mut _,
                destroy_call4,
            ))
        }
    }

    fn icon_paths(&self) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::dbusmenu_client_get_icon_paths(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn root(&self) -> Option<Menuitem> {
        unsafe {
            from_glib_none(ffi::dbusmenu_client_get_root(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn status(&self) -> Status {
        unsafe {
            from_glib(ffi::dbusmenu_client_get_status(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn text_direction(&self) -> TextDirection {
        unsafe {
            from_glib(ffi::dbusmenu_client_get_text_direction(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn dbus_name(&self) -> Option<glib::GString> {
        glib::prelude::ObjectExt::property(self.as_ref(), "dbus-name")
    }

    fn dbus_object(&self) -> Option<glib::GString> {
        glib::prelude::ObjectExt::property(self.as_ref(), "dbus-object")
    }

    fn is_group_events(&self) -> bool {
        glib::prelude::ObjectExt::property(self.as_ref(), "group-events")
    }

    fn set_group_events(&self, group_events: bool) {
        glib::prelude::ObjectExt::set_property(self.as_ref(), "group-events", group_events)
    }

    //fn connect_event_result<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored object: GObject.Object
    //    Unimplemented p3: *.Pointer
    //}

    //fn connect_icon_theme_dirs_changed<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Unimplemented arg1: *.Pointer
    //}

    //fn connect_item_activate<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored arg1: GObject.Object
    //}

    fn connect_layout_updated<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn layout_updated_trampoline<P: IsA<Client>, F: Fn(&P) + 'static>(
            this: *mut ffi::DbusmenuClient,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Client::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"layout-updated\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    layout_updated_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    //fn connect_new_menuitem<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored arg1: GObject.Object
    //}

    //fn connect_root_changed<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored arg1: GObject.Object
    //}

    fn connect_group_events_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_group_events_trampoline<P: IsA<Client>, F: Fn(&P) + 'static>(
            this: *mut ffi::DbusmenuClient,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Client::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::group-events\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_group_events_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl fmt::Display for Client {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("Client")
    }
}
